REM PX-LUA Class
DEF CLASS "lua" CREATE REQUIRED DELETE REQUIRED 
! -----------PUBLIC PROPERTIES-----------
! -----------PRIVATE PROPERTIES----------
LOCAL DLL_FILENAME$="LUA51.DLL"
LOCAL LUA_DLL
LOCAL LUA_STATE
! -----------PUBLIC FUNCTIONS------------
FUNCTION RUN_STRING(STRING$)RUN_STRING_NUM
FUNCTION RUN_STRING$(STRING$)RUN_STRING_STR
FUNCTION RUN_FILE(FILENAME$)RUN_FILE_NUM
FUNCTION RUN_FILE$(FILENAME$)RUN_FILE_STR
! -----------HIDDEN FUNCTIONS------------
FUNCTION HIDE LOAD_FILE(FILENAME$)LOAD_FILE
FUNCTION HIDE LOAD_STRING(FILENAME$)LOAD_STRING
FUNCTION HIDE RUN_LOADED()RUN_LOADED_NUM
FUNCTION HIDE RUN_LOADED$()RUN_LOADED_STR
! -----------PRIVATE FUNCTIONS-----------
FUNCTION LOCAL HIDE LUA_GETGLOBAL(NAME$)LUA_GETGLOBAL
FUNCTION LOCAL HIDE LUA_POP(NUMBER_OF_ELEMENTS)LUA_POP
FUNCTION LOCAL HIDE GET_STRING_FROM_STACK$()GET_STRING_FROM_STACK
FUNCTION LOCAL HIDE HANDLE_ERROR(FUNCTION_NAME$,FUNC_CALL_RESULT)HANDLE_ERROR
END DEF
ON_CREATE:
LET LUA_DLL=DLL(ADDR DLL_FILENAME$) REM load the dll
LET LUA_STATE=DLL(LUA_DLL,"luaL_newstate") REM create a new state
LET IGNORE=DLL(LUA_DLL,"luaL_openlibs",LUA_STATE) REM open the standard libraries
RETURN 
ON_DELETE:
LET IGNORE=DLL(LUA_DLL,"lua_close",LUA_STATE) REM close the lua state
RETURN 
! 
! 
! 
! -----------PUBLIC FUNCTIONS------------
RUN_STRING_NUM:
ENTER STRING$
_OBJ'LOAD_STRING(STRING$)
RETURN _OBJ'RUN_LOADED()
RUN_STRING_STR:
ENTER STRING$
_OBJ'LOAD_STRING(STRING$)
RETURN _OBJ'RUN_LOADED$()
! 
! 
! 
RUN_FILE_NUM:
ENTER FILENAME$
_OBJ'LOAD_FILE(FILENAME$)
RETURN _OBJ'RUN_LOADED()
RUN_FILE_STR:
ENTER FILENAME$
_OBJ'LOAD_FILE(FILENAME$)
RETURN _OBJ'RUN_LOADED$()
! 
! 
! 
! -----------HIDDEN FUNCTIONS------------
LOAD_FILE:
ENTER FILENAME$
LOCAL LOAD_RESULT=DLL(LUA_DLL,"luaL_loadfile",LUA_STATE,FILENAME$)
IF LOAD_RESULT<>0 THEN _OBJ'HANDLE_ERROR("luaL_loadfile",LOAD_RESULT)
RETURN LOAD_RESULT
LOAD_STRING:
ENTER STRING$
REM lua needs null terminated strings, and providex adds some random crap on the end of strings for some reason i don't know
REM So i need to null terminate the string at the correct location
LOCAL LOCAL_STRING$=STRING$
LET IGNORETHIS$=MEM(MEM(LOCAL_STRING$)+LEN(LOCAL_STRING$),$00$)
LOCAL LOAD_RESULT=DLL(LUA_DLL,"luaL_loadstring",LUA_STATE,LOCAL_STRING$)
IF LOAD_RESULT<>0 THEN _OBJ'HANDLE_ERROR("luaL_loadstring",LOAD_RESULT)
RETURN LOAD_RESULT
! 
! 
! 
RUN_LOADED_NUM:
LOCAL CALL_RESULT=DLL(LUA_DLL,"lua_pcall",LUA_STATE,0,-1,0)
IF CALL_RESULT=0 THEN LET RESULT=DLL(LUA_DLL,"lua_tonumber",LUA_STATE,-1) ELSE _OBJ'HANDLE_ERROR("lua_pcall",CALL_RESULT)
REM if the return value is something other than 0, remove that result off the lua-stack
IF RESULT<>0 THEN _OBJ'LUA_POP(1)
RETURN RESULT
RUN_LOADED_STR:
LOCAL CALL_RESULT=DLL(LUA_DLL,"lua_pcall",LUA_STATE,0,-1,0)
IF CALL_RESULT=0 THEN LET FIRST_BYTE=DLL(LUA_DLL,"lua_tolstring",LUA_STATE,-1) ELSE _OBJ'HANDLE_ERROR("lua_pcall",CALL_RESULT)
REM If the first_byte is 0, then just return 0, there was no return value pushed to the stack
IF FIRST_BYTE=0 THEN RETURN "" ELSE RETURN _OBJ'GET_STRING_FROM_STACK$()
! 
! 
! 
! -----------PRIVATE FUNCTIONS-----------
LUA_GETGLOBAL:
ENTER NAME$
LET IGNORE=DLL(LUA_DLL,"lua_getfield",LUA_STATE,-10002,NAME$)
RETURN 
! 
! 
! 
LUA_POP:
ENTER NUMBER_OF_ELEMENTS
RETURN DLL(LUA_DLL,"lua_settop",LUA_STATE,((NUMBER_OF_ELEMENTS-1)*-1))
! 
! 
! 
GET_STRING_FROM_STACK:
LET FIRST_BYTE=DLL(LUA_DLL,"lua_tolstring",LUA_STATE,-1)
IF FIRST_BYTE=0 THEN RETURN ""
REM the tolstring returns the memory address of the first byte
REM mem() returns the string at the given address, 0 length means it keeps going until it finds a null byte /0
LET RESULT$=MEM(FIRST_BYTE,0)
REM remove that result off the lua-stack
_OBJ'LUA_POP(1)
RETURN RESULT$
! 
! 
! 
HANDLE_ERROR:
ENTER FUNCTION_NAME$,FUNC_CALL_RESULT
MSGBOX "Error in "+FUNCTION_NAME$+SEP+"Err Number: "+STR(FUNC_CALL_RESULT)+SEP+"Err: "+_OBJ'GET_STRING_FROM_STACK$()
RETURN 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
